# Numeric ID Implementation Guide

**Last updated:** 2025-10-31

**Status:** Ready for implementation

---

## Table of Contents

1. [Base Concepts](#base-concepts)
2. [Why Numeric IDs for HuntHub](#why-numeric-ids-for-hunthub)
3. [Architecture Overview](#architecture-overview)
4. [Implementation Pattern](#implementation-pattern)
5. [Counter Safety & Protection](#counter-safety--protection)
6. [Step-by-Step Migration Plan](#step-by-step-migration-plan)
7. [Testing Strategy](#testing-strategy)
8. [Production Standards Reference](#production-standards-reference)

---

## Base Concepts

### The Problem: Exposing MongoDB ObjectIds

**What are MongoDB ObjectIds?**
- 12-byte identifier automatically generated by MongoDB
- Format: `507f1f77bcf86cd799439011` (24-character hex string)
- Contains timestamp, machine ID, process ID, and counter

**Why NOT to expose them in APIs:**

1. **Security**: Contains timestamp → reveals creation time and order
2. **Implementation Leakage**: Tells everyone you use MongoDB
3. **Migration Lock-in**: Tied to MongoDB format forever
4. **Predictability**: Somewhat sequential, enumeration attacks easier
5. **User Experience**: Not human-readable or memorable

**Example of the problem:**
```json
// ❌ BAD - Current HuntHub API response
{
  "id": "507f1f77bcf86cd799439011",  // MongoDB ObjectId exposed
  "huntId": "507f191e810c19729de860ea", // Not human-readable
  "name": "Barcelona Adventure"
}
```

### The Solution: Dual ID System

**Pattern: Internal ObjectId + External Numeric ID**

```json
// ✅ GOOD - With numeric IDs
{
  "huntId": 1332,      // Human-readable, short, memorable
  "name": "Barcelona Adventure",
  "creatorId": "firebase-uid-abc123"  // NOT MongoDB ObjectId!
}
```

**Two IDs per document:**
- **Internal ID (`_id`)**: MongoDB ObjectId - never exposed, used internally
- **External ID (`huntId`, `stepId`)**: Numeric sequential - exposed in API, user-facing

**Database structure:**
```javascript
// MongoDB document
{
  _id: ObjectId("507f1f77bcf86cd799439011"),  // Internal
  huntId: 1332,                                // External (API)
  creatorId: "firebase-uid-abc123",
  name: "Barcelona Adventure",
  stepOrder: [10000, 10001, 10002]             // References step numeric IDs
}
```

### How to Generate Sequential IDs in MongoDB

**Challenge:** MongoDB has no built-in auto-increment like PostgreSQL

**Solution: Counter Collection Pattern** (Industry Standard)

```javascript
// counters collection
{
  _id: ObjectId("..."),
  name: "hunt",      // Counter identifier
  seq: 1332          // Current value
}
```

**Atomic increment operation:**
```javascript
db.counters.findOneAndUpdate(
  { name: "hunt" },
  { $inc: { seq: 1 } },  // Atomic increment
  { new: true }          // Return updated value
);
// Returns: { name: "hunt", seq: 1333 }
```

**MongoDB guarantees:**
- ✅ **Atomic**: No race conditions, even with concurrent requests
- ✅ **Unique**: Counter cannot skip or duplicate
- ⚠️ **Gaps possible**: If document creation fails after incrementing (acceptable)

---

## Why Numeric IDs for HuntHub

### 1. User Experience

**Human-readable and memorable:**
- "Check out hunt 1332" vs "Check out hunt 507f1f77bcf86cd799439011"
- Easy to verbally communicate
- Short enough for QR codes

**Short URLs:**
```
https://hunthub.com/play/1332        ✅ Clean, shareable
https://hunthub.com/play/507f1f...   ❌ Long, ugly
```

### 2. Security

**Hide implementation details:**
- ❌ ObjectId: `507f1f77bcf86cd799439011` → tells you we use MongoDB
- ✅ Numeric: `1332` → database-agnostic

**Remove timestamp leakage:**
- ObjectIds embed creation timestamp
- Numeric IDs don't reveal order or timing

**Authorization-based security:**
- Enumeration (trying hunt 1, 2, 3...) is **safe** with proper auth
- HuntHub has authorization: `verifyOwnership()` checks creator
- GitHub, Twitter, Stripe all use sequential IDs with auth

### 3. Production Standards

**Who uses numeric IDs:**
- ✅ **GitHub**: Issue numbers, PR numbers (#1332)
- ✅ **Twitter**: Tweet IDs (numeric, not UUIDs)
- ✅ **Stripe**: Customer IDs (sequential with prefix: `cus_1332`)
- ✅ **Instagram**: Post IDs (Snowflake IDs - 64-bit integers)

**Pattern validation:**
- Counter pattern is MongoDB best practice
- Instagram uses this pattern with PostgreSQL (sequences)
- Not overengineering - this IS the standard

### 4. Developer Experience

**Easier debugging:**
```javascript
// ✅ Easy to spot in logs
GET /api/hunts/1332
Step 10001 belongs to hunt 1332

// ❌ Hard to distinguish
GET /api/hunts/507f1f77bcf86cd799439011
Step 507f191e810c19729de860ea belongs to hunt 507f1f77bcf86cd799439011
```

**Simpler testing:**
```javascript
// Test fixtures are readable
const hunt1 = { huntId: 1000, name: "Test Hunt 1" };
const hunt2 = { huntId: 1001, name: "Test Hunt 2" };
```

---

## Architecture Overview

### Scope Decision: Which Models?

**✅ Use Numeric IDs:**
- **Hunt** (`huntId` starting at 1000)
  - User-facing in URLs, QR codes
  - Needs to be memorable and short

- **Step** (`stepId` starting at 10000)
  - User-facing in editor and player
  - Distinguishable from hunt IDs (different magnitude)

**❌ Do NOT use Numeric IDs:**
- **User** - Already has Firebase UID (external system)
- **Asset** - Users see images, not IDs (internal reference only)
- **Progress** - Internal tracking, never user-facing
- **PublishedHunt** - Use `huntId` + `version` composite key
- **LiveHunt** - References `huntId`, no separate ID needed

**Rationale:**
- YAGNI: Only add complexity where user-facing benefit exists
- Can add Asset numeric IDs later if needed (easy to extend)

### Starting Values

**Hunt IDs start at 1000:**
```javascript
{ name: 'hunt', seq: 999 }  // First hunt = 1000
```

**Step IDs start at 10000:**
```javascript
{ name: 'step', seq: 9999 }  // First step = 10000
```

**Why different starting values:**
- ✅ Distinguishable at a glance (1332 is hunt, 10045 is step)
- ✅ Professional appearance (avoids hunt #1, #2)
- ✅ No collision risk (hunt IDs and step IDs in different ranges)
- ✅ Allows 8,999 hunts before reaching step ID range

### Database Schema Changes

**Before (exposing ObjectIds):**
```javascript
// Hunt document
{
  _id: ObjectId("507f1f77bcf86cd799439011"),
  creatorId: "firebase-uid-abc",
  name: "Barcelona Adventure",
  stepOrder: [
    ObjectId("507f191e810c19729de860ea"),  // Step references
    ObjectId("507f191e810c19729de860eb")
  ]
}

// API response exposes ObjectId
{
  "id": "507f1f77bcf86cd799439011",  // ❌ MongoDB ObjectId
  "creatorId": "firebase-uid-abc",
  "name": "Barcelona Adventure"
}
```

**After (with numeric IDs):**
```javascript
// Hunt document
{
  _id: ObjectId("507f1f77bcf86cd799439011"),  // Internal only
  huntId: 1332,                                // External API ID
  creatorId: "firebase-uid-abc",
  name: "Barcelona Adventure",
  stepOrder: [10000, 10001]                    // Numeric step IDs
}

// Step document
{
  _id: ObjectId("507f191e810c19729de860ea"),  // Internal only
  stepId: 10000,                               // External API ID
  huntId: 1332,                                // Foreign key to hunt
  type: "clue",
  challenge: { ... }
}

// API response
{
  "huntId": 1332,  // ✅ Numeric, human-readable
  "creatorId": "firebase-uid-abc",
  "name": "Barcelona Adventure",
  "stepOrder": [10000, 10001]
}
```

**Key changes:**
1. Add `huntId: number` and `stepId: number` fields
2. Add unique indexes on these fields
3. Change `stepOrder` from `ObjectId[]` to `number[]`
4. Foreign key references use numeric IDs

**MongoDB populate still works:**
```javascript
// Can still use populate with ObjectId references
const huntSchema = new Schema({
  stepOrder: [{ type: Schema.Types.ObjectId, ref: 'Step' }]  // ✅ Works
});

// MongoDB uses _id internally for population
await Hunt.findOne({ huntId: 1332 }).populate('stepOrder');
```

---

## Implementation Pattern

### 1. Counter Model

**File:** `apps/backend/api/src/database/models/Counter.ts`

```typescript
import { Schema, model } from 'mongoose';

export interface ICounter {
  name: string;  // 'hunt' or 'step'
  seq: number;   // Current counter value
}

const counterSchema = new Schema<ICounter>({
  name: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  seq: {
    type: Number,
    required: true
  }
});

/**
 * Get next sequential ID for a counter
 * Uses atomic $inc operation - NO race conditions
 */
export async function getNextSequence(counterName: string): Promise<number> {
  const counter = await CounterModel.findOneAndUpdate(
    { name: counterName },
    { $inc: { seq: 1 } },  // Atomic increment
    { new: true }          // Return updated value
  );

  if (!counter) {
    throw new Error(
      `Counter '${counterName}' not found. ` +
      `Run 'npm run init-counters' to initialize.`
    );
  }

  return counter.seq;
}

const CounterModel = model<ICounter>('Counter', counterSchema);
export default CounterModel;
```

**Key points:**
- `findOneAndUpdate` with `$inc` is **atomic** (MongoDB guarantee)
- No race conditions even with concurrent requests
- Returns new value immediately
- Throws clear error if counter not initialized

### 2. Update Hunt Model

**File:** `apps/backend/api/src/database/models/Hunt.ts`

```typescript
import { Schema, model } from 'mongoose';
import { IHunt } from '../types/Hunt';
import { getNextSequence } from './Counter';

const huntSchema = new Schema<IHunt>(
  {
    // NEW: Numeric ID field
    huntId: {
      type: Number,
      required: true,
      unique: true,
      index: true
    },

    // Existing fields
    creatorId: { type: String, required: true },
    name: { type: String, required: true },
    description: { type: String },
    status: { type: String, enum: ['draft', 'published'], default: 'draft' },

    // CHANGED: stepOrder now uses numeric IDs
    stepOrder: [{ type: Number }],  // Array of step numeric IDs

    currentVersion: { type: Number, default: 1 }
  },
  { timestamps: true }
);

// Pre-save hook: Auto-generate huntId
huntSchema.pre('save', async function() {
  if (this.isNew && !this.huntId) {
    this.huntId = await getNextSequence('hunt');
  }
});

// Indexes
huntSchema.index({ creatorId: 1 });
huntSchema.index({ huntId: 1 }, { unique: true });

const HuntModel = model<IHunt>('Hunt', huntSchema);
export default HuntModel;
```

**Key changes:**
1. Added `huntId: number` field with unique index
2. Pre-save hook calls `getNextSequence('hunt')`
3. Changed `stepOrder` from `ObjectId[]` to `number[]`
4. Check `this.isNew` to only generate ID on creation

### 3. Update Step Model

**File:** `apps/backend/api/src/database/models/Step.ts`

```typescript
import { Schema, model } from 'mongoose';
import { IStep } from '../types/Step';
import { getNextSequence } from './Counter';

const stepSchema = new Schema<IStep>(
  {
    // NEW: Numeric ID field
    stepId: {
      type: Number,
      required: true,
      unique: true,
      index: true
    },

    // CHANGED: Foreign key to hunt (numeric)
    huntId: { type: Number, required: true, index: true },

    // Existing fields
    type: { type: String, enum: ['clue', 'quiz', 'mission', 'task'], required: true },
    challenge: { type: Schema.Types.Mixed, required: true },
    hint: { type: String },
    requiredLocation: {
      lat: Number,
      lng: Number,
      radius: Number
    },
    metadata: { type: Schema.Types.Mixed }
  },
  { timestamps: true }
);

// Pre-save hook: Auto-generate stepId
stepSchema.pre('save', async function() {
  if (this.isNew && !this.stepId) {
    this.stepId = await getNextSequence('step');
  }
});

// Indexes
stepSchema.index({ huntId: 1 });
stepSchema.index({ stepId: 1 }, { unique: true });

const StepModel = model<IStep>('Step', stepSchema);
export default StepModel;
```

**Key changes:**
1. Added `stepId: number` field with unique index
2. Changed `huntId` from `ObjectId` to `number` (foreign key)
3. Pre-save hook calls `getNextSequence('step')`

### 4. Update TypeScript Interfaces

**File:** `apps/backend/api/src/database/types/Hunt.ts`

```typescript
import mongoose from 'mongoose';

export interface IHunt {
  _id: mongoose.Types.ObjectId;  // Internal MongoDB ID
  huntId: number;                 // External API ID (NEW)
  creatorId: string;
  name: string;
  description?: string;
  status: 'draft' | 'published';
  stepOrder: number[];            // Changed from ObjectId[] to number[]
  currentVersion: number;
  createdAt: Date;
  updatedAt: Date;
}
```

**File:** `apps/backend/api/src/database/types/Step.ts`

```typescript
import mongoose from 'mongoose';

export interface IStep {
  _id: mongoose.Types.ObjectId;  // Internal MongoDB ID
  stepId: number;                 // External API ID (NEW)
  huntId: number;                 // Changed from ObjectId to number
  type: 'clue' | 'quiz' | 'mission' | 'task';
  challenge: unknown;
  hint?: string;
  requiredLocation?: {
    lat: number;
    lng: number;
    radius: number;
  };
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}
```

### 5. Update OpenAPI Schema

**File:** `packages/shared/openapi/hunthub_models.yaml`

```yaml
components:
  schemas:
    Hunt:
      type: object
      required:
        - huntId    # Changed from 'id'
        - name
        - creatorId
        - status
      properties:
        huntId:     # Changed from 'id'
          type: integer
          example: 1332
        name:
          type: string
          minLength: 3
          maxLength: 100
        creatorId:
          type: string
        status:
          type: string
          enum: [draft, published]
        stepOrder:
          type: array
          items:
            type: integer  # Changed from string
          example: [10000, 10001, 10002]

    Step:
      type: object
      required:
        - stepId    # Changed from 'id'
        - huntId
        - type
        - challenge
      properties:
        stepId:     # Changed from 'id'
          type: integer
          example: 10000
        huntId:     # Changed to integer
          type: integer
          example: 1332
        type:
          type: string
          enum: [clue, quiz, mission, task]
        challenge:
          oneOf:
            - $ref: '#/components/schemas/ClueChallenge'
            - $ref: '#/components/schemas/QuizChallenge'
            - $ref: '#/components/schemas/MissionChallenge'
            - $ref: '#/components/schemas/TaskChallenge'
```

**After OpenAPI update:**
```bash
npm run generate  # Regenerate TypeScript types from OpenAPI
```

### 6. Update Mappers

**File:** `apps/backend/api/src/shared/mappers/hunt.mapper.ts`

```typescript
import { Hunt } from '@hunthub/shared/types';
import { IHunt } from '../../database/types/Hunt';

export class HuntMapper {
  /**
   * Convert API DTO to Mongoose document format
   */
  static toDocument(dto: Partial<Hunt>): Partial<IHunt> {
    return {
      // Don't include huntId - auto-generated by pre-save hook
      creatorId: dto.creatorId,
      name: dto.name,
      description: dto.description,
      status: dto.status,
      stepOrder: dto.stepOrder || []  // Already numeric IDs
    };
  }

  /**
   * Convert Mongoose document to API response
   */
  static fromDocument(doc: IHunt): Hunt {
    return {
      huntId: doc.huntId,  // Use numeric ID, NOT _id
      creatorId: doc.creatorId,
      name: doc.name,
      description: doc.description,
      status: doc.status,
      stepOrder: doc.stepOrder,
      currentVersion: doc.currentVersion,
      createdAt: doc.createdAt.toISOString(),
      updatedAt: doc.updatedAt.toISOString()
    };
  }
}
```

**File:** `apps/backend/api/src/shared/mappers/step.mapper.ts`

```typescript
import { Step } from '@hunthub/shared/types';
import { IStep } from '../../database/types/Step';

export class StepMapper {
  static toDocument(dto: Partial<Step>): Partial<IStep> {
    return {
      // Don't include stepId - auto-generated by pre-save hook
      huntId: dto.huntId,  // Numeric foreign key
      type: dto.type,
      challenge: dto.challenge,
      hint: dto.hint,
      requiredLocation: dto.requiredLocation,
      metadata: dto.metadata
    };
  }

  static fromDocument(doc: IStep): Step {
    return {
      stepId: doc.stepId,  // Use numeric ID, NOT _id
      huntId: doc.huntId,  // Numeric foreign key
      type: doc.type,
      challenge: doc.challenge,
      hint: doc.hint,
      requiredLocation: doc.requiredLocation,
      metadata: doc.metadata,
      createdAt: doc.createdAt.toISOString(),
      updatedAt: doc.updatedAt.toISOString()
    };
  }
}
```

**Key mapper changes:**
- ✅ Return `huntId` and `stepId` (numeric) in `fromDocument()`
- ❌ Never return `_id` (MongoDB ObjectId)
- ✅ Don't include numeric IDs in `toDocument()` (auto-generated)

### 7. Update Services

**File:** `apps/backend/api/src/modules/hunts/hunt.service.ts`

```typescript
import HuntModel from '../../database/models/Hunt';
import StepModel from '../../database/models/Step';
import { HuntMapper } from '../../shared/mappers/hunt.mapper';

export class HuntService {
  /**
   * Get hunt by numeric ID
   */
  async getHuntById(huntId: number): Promise<Hunt> {
    const hunt = await HuntModel.findOne({ huntId }).exec();

    if (!hunt) {
      throw new NotFoundError(`Hunt ${huntId} not found`);
    }

    return HuntMapper.fromDocument(hunt);
  }

  /**
   * Create new hunt (huntId auto-generated)
   */
  async createHunt(data: HuntCreate, creatorId: string): Promise<Hunt> {
    const hunt = await HuntModel.create({
      ...HuntMapper.toDocument(data),
      creatorId
      // huntId will be auto-generated by pre-save hook
    });

    return HuntMapper.fromDocument(hunt);
  }

  /**
   * Delete hunt and all its steps
   */
  async deleteHunt(huntId: number): Promise<void> {
    const hunt = await HuntModel.findOne({ huntId }).exec();

    if (!hunt) {
      throw new NotFoundError(`Hunt ${huntId} not found`);
    }

    // Delete all steps
    await StepModel.deleteMany({ huntId }).exec();

    // Delete hunt
    await HuntModel.deleteOne({ huntId }).exec();
  }

  /**
   * Reorder steps
   */
  async reorderSteps(huntId: number, stepIds: number[]): Promise<Hunt> {
    const hunt = await HuntModel.findOne({ huntId }).exec();

    if (!hunt) {
      throw new NotFoundError(`Hunt ${huntId} not found`);
    }

    // Validate all steps exist and belong to this hunt
    const steps = await StepModel.find({
      stepId: { $in: stepIds },
      huntId: huntId
    }).exec();

    if (steps.length !== stepIds.length) {
      throw new ValidationError('Some steps not found or do not belong to this hunt');
    }

    // Update stepOrder
    hunt.stepOrder = stepIds;
    await hunt.save();

    return HuntMapper.fromDocument(hunt);
  }
}
```

**File:** `apps/backend/api/src/modules/steps/step.service.ts`

```typescript
import StepModel from '../../database/models/Step';
import HuntModel from '../../database/models/Hunt';
import { StepMapper } from '../../shared/mappers/step.mapper';

export class StepService {
  /**
   * Create step (stepId auto-generated)
   */
  async createStep(huntId: number, data: StepCreate): Promise<Step> {
    // Verify hunt exists
    const hunt = await HuntModel.findOne({ huntId }).exec();
    if (!hunt) {
      throw new NotFoundError(`Hunt ${huntId} not found`);
    }

    // Create step
    const step = await StepModel.create({
      ...StepMapper.toDocument(data),
      huntId: huntId
      // stepId will be auto-generated by pre-save hook
    });

    // Append to hunt's stepOrder
    hunt.stepOrder.push(step.stepId);
    await hunt.save();

    return StepMapper.fromDocument(step);
  }

  /**
   * Delete step
   */
  async deleteStep(huntId: number, stepId: number): Promise<void> {
    // Verify hunt exists
    const hunt = await HuntModel.findOne({ huntId }).exec();
    if (!hunt) {
      throw new NotFoundError(`Hunt ${huntId} not found`);
    }

    // Verify step exists and belongs to hunt
    const step = await StepModel.findOne({ stepId, huntId }).exec();
    if (!step) {
      throw new NotFoundError(`Step ${stepId} not found`);
    }

    // Remove from hunt's stepOrder
    hunt.stepOrder = hunt.stepOrder.filter(id => id !== stepId);
    await hunt.save();

    // Delete step
    await StepModel.deleteOne({ stepId }).exec();
  }
}
```

**Key service changes:**
- ✅ Query by `huntId` or `stepId` (numeric), not `_id`
- ✅ Foreign key references use numeric IDs
- ✅ No manual ID generation (pre-save hooks handle it)

### 8. Update Routes (No Changes!)

**Routes stay the same:**
```typescript
// apps/backend/api/src/modules/hunts/hunt.routes.ts
router.get('/:huntId', controller.getHuntById);
router.delete('/:huntId', controller.deleteHunt);
router.post('/:huntId/steps', controller.createStep);
```

**URLs work with numeric IDs:**
```
GET /api/hunts/1332         ✅ Returns hunt 1332
GET /api/hunts/1332/steps   ✅ Returns steps for hunt 1332
POST /api/hunts/1332/steps  ✅ Creates step in hunt 1332
```

---

## Counter Safety & Protection

### MongoDB Atomicity Guarantees

**Question:** Can counters have race conditions?

**Answer:** NO - `findOneAndUpdate` with `$inc` is atomic

```javascript
// Two requests at exact same time:
Request 1: getNextSequence('hunt')  // Gets 1000
Request 2: getNextSequence('hunt')  // Gets 1001

// MongoDB guarantees:
// - Both requests CANNOT get the same value
// - Counter increments atomically
// - No locks needed (MongoDB handles it internally)
```

**MongoDB documentation:**
> "All write operations in MongoDB are atomic on the level of a single document."

**What this means:**
- ✅ **Zero risk** of duplicate IDs
- ✅ **Zero risk** of race conditions
- ✅ Works even with 100+ concurrent requests
- ⚠️ **Gaps possible** if document creation fails after incrementing (acceptable)

### Can Counters Be Deleted?

**Risk:** Developer or script accidentally deletes counter document

**Impact:** App crashes on next hunt/step creation

```javascript
// If counter deleted:
await getNextSequence('hunt');
// Throws: "Counter 'hunt' not found. Run 'npm run init-counters' to initialize."
```

**Protection Strategy: MongoDB RBAC (Role-Based Access Control)**

Create application user with restricted permissions:

```javascript
// MongoDB setup (run once)
db.createRole({
  role: 'hunthubApp',
  privileges: [
    // Counters: read and update ONLY (NO delete!)
    {
      resource: { db: 'hunthub', collection: 'counters' },
      actions: ['find', 'update']  // Missing 'remove' action
    },

    // Other collections: full CRUD
    {
      resource: { db: 'hunthub', collection: 'hunts' },
      actions: ['find', 'insert', 'update', 'remove']
    },
    {
      resource: { db: 'hunthub', collection: 'steps' },
      actions: ['find', 'insert', 'update', 'remove']
    }
  ],
  roles: []
});

db.createUser({
  user: 'hunthubApp',
  pwd: process.env.APP_PASSWORD,
  roles: ['hunthubApp']
});
```

**Result:**
- ✅ App can read and increment counters
- ❌ App CANNOT delete counters (MongoDB rejects)
- ✅ Admin users can still manage counters (different role)

**Why this is sufficient:**
- RBAC prevents accidental deletion via app code
- Malicious code cannot delete counters (no permissions)
- Admin access still available for maintenance
- **No recovery script needed** (RBAC is the protection)

### Counter Initialization

**Problem:** Counters must exist before first use

**Solution: Pre-initialize with deployment script** (Production Standard)

**File:** `apps/backend/api/scripts/init-counters.ts`

```typescript
import mongoose from 'mongoose';
import CounterModel from '../src/database/models/Counter';

async function initializeCounters() {
  await mongoose.connect(process.env.MONGO_URI!);

  const counters = [
    { name: 'hunt', seq: 999 },   // First hunt ID = 1000
    { name: 'step', seq: 9999 },  // First step ID = 10000
  ];

  for (const counter of counters) {
    const result = await CounterModel.updateOne(
      { name: counter.name },
      { $setOnInsert: counter },  // Only sets if document doesn't exist
      { upsert: true }
    );

    if (result.upsertedCount > 0) {
      console.log(`✅ Counter '${counter.name}' initialized to ${counter.seq}`);
    } else {
      console.log(`ℹ️  Counter '${counter.name}' already exists`);
    }
  }

  console.log('✅ All counters initialized');
  await mongoose.disconnect();
}

initializeCounters().catch(console.error);
```

**Key points:**
- `$setOnInsert` only creates counter if it doesn't exist
- Safe to run multiple times (idempotent)
- Run once during deployment setup
- No runtime overhead (not checked on every request)

**Add to package.json:**
```json
{
  "scripts": {
    "init-counters": "ts-node apps/backend/api/scripts/init-counters.ts"
  }
}
```

**Run once:**
```bash
npm run init-counters
```

**Why this pattern:**
- ✅ **Production standard**: Initialize infrastructure during deployment
- ✅ **No runtime overhead**: Counters checked once, not every request
- ✅ **Clear separation**: Setup vs runtime logic
- ✅ **Fail fast**: App errors if counters missing (not silent failure)

---

## Step-by-Step Migration Plan

### Prerequisites

- [ ] All Week 1 endpoints working (Hunt CRUD, Step CRUD)
- [ ] MongoDB connection configured
- [ ] Backend compiles without errors

### Phase 1: Create Counter Infrastructure (30 minutes)

**Step 1.1: Create Counter model**
```bash
# Create file
touch apps/backend/api/src/database/models/Counter.ts
```

Copy implementation from [Implementation Pattern > 1. Counter Model](#1-counter-model)

**Step 1.2: Create initialization script**
```bash
# Create file
touch apps/backend/api/scripts/init-counters.ts
```

Copy implementation from [Counter Safety > Counter Initialization](#counter-initialization)

**Step 1.3: Add script to package.json**
```json
{
  "scripts": {
    "init-counters": "ts-node apps/backend/api/scripts/init-counters.ts"
  }
}
```

**Step 1.4: Test counter creation**
```bash
npm run init-counters

# Expected output:
# ✅ Counter 'hunt' initialized to 999
# ✅ Counter 'step' initialized to 9999
# ✅ All counters initialized
```

**Step 1.5: Verify in MongoDB**
```bash
mongosh $MONGO_URI

use hunthub
db.counters.find()

# Should see:
# { _id: ObjectId(...), name: 'hunt', seq: 999 }
# { _id: ObjectId(...), name: 'step', seq: 9999 }
```

### Phase 2: Update Hunt Model (20 minutes)

**Step 2.1: Update Hunt interface**

File: `apps/backend/api/src/database/types/Hunt.ts`

```typescript
export interface IHunt {
  _id: mongoose.Types.ObjectId;
  huntId: number;         // ← ADD THIS
  creatorId: string;
  name: string;
  description?: string;
  status: 'draft' | 'published';
  stepOrder: number[];    // ← CHANGE from ObjectId[]
  currentVersion: number;
  createdAt: Date;
  updatedAt: Date;
}
```

**Step 2.2: Update Hunt schema**

File: `apps/backend/api/src/database/models/Hunt.ts`

Add numeric ID field + pre-save hook (see [Implementation Pattern > 2. Update Hunt Model](#2-update-hunt-model))

**Step 2.3: Update Hunt mapper**

File: `apps/backend/api/src/shared/mappers/hunt.mapper.ts`

Change `fromDocument()` to return `huntId` instead of `_id` (see [Implementation Pattern > 6. Update Mappers](#6-update-mappers))

**Step 2.4: Test Hunt creation**
```bash
npm run dev

# Make request:
curl -X POST http://localhost:3000/api/hunts \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Hunt", "description": "Testing numeric IDs"}'

# Expected response:
{
  "huntId": 1000,  // ← First hunt!
  "name": "Test Hunt",
  "status": "draft",
  "stepOrder": []
}
```

**Step 2.5: Verify counter incremented**
```bash
mongosh $MONGO_URI

db.counters.findOne({ name: 'hunt' })
# { name: 'hunt', seq: 1000 }  ← Incremented!
```

### Phase 3: Update Step Model (20 minutes)

**Step 3.1: Update Step interface**

File: `apps/backend/api/src/database/types/Step.ts`

```typescript
export interface IStep {
  _id: mongoose.Types.ObjectId;
  stepId: number;    // ← ADD THIS
  huntId: number;    // ← CHANGE from ObjectId
  type: 'clue' | 'quiz' | 'mission' | 'task';
  challenge: unknown;
  hint?: string;
  requiredLocation?: {
    lat: number;
    lng: number;
    radius: number;
  };
  metadata?: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}
```

**Step 3.2: Update Step schema**

File: `apps/backend/api/src/database/models/Step.ts`

Add numeric ID field + pre-save hook (see [Implementation Pattern > 3. Update Step Model](#3-update-step-model))

**Step 3.3: Update Step mapper**

File: `apps/backend/api/src/shared/mappers/step.mapper.ts`

Change `fromDocument()` to return `stepId` and numeric `huntId` (see [Implementation Pattern > 6. Update Mappers](#6-update-mappers))

**Step 3.4: Test Step creation**
```bash
# Create step in hunt 1000
curl -X POST http://localhost:3000/api/hunts/1000/steps \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "clue",
    "challenge": {
      "clue": {
        "title": "Test Clue",
        "description": "Find the statue"
      }
    }
  }'

# Expected response:
{
  "stepId": 10000,  // ← First step!
  "huntId": 1000,   // ← Numeric foreign key
  "type": "clue",
  "challenge": { ... }
}
```

**Step 3.5: Verify counter and stepOrder**
```bash
mongosh $MONGO_URI

# Check counter
db.counters.findOne({ name: 'step' })
# { name: 'step', seq: 10000 }  ← Incremented!

# Check hunt's stepOrder
db.hunts.findOne({ huntId: 1000 })
# { huntId: 1000, stepOrder: [10000], ... }  ← Numeric ID in array!
```

### Phase 4: Update Services (30 minutes)

**Step 4.1: Update HuntService queries**

File: `apps/backend/api/src/modules/hunts/hunt.service.ts`

Change all queries from `_id` to `huntId`:
- `findById()` → `findOne({ huntId })`
- `deleteOne()` → `deleteOne({ huntId })`

See [Implementation Pattern > 7. Update Services](#7-update-services) for complete examples

**Step 4.2: Update StepService queries**

File: `apps/backend/api/src/modules/steps/step.service.ts`

Change queries to use numeric IDs:
- `findOne({ _id, huntId })` → `findOne({ stepId, huntId })`
- Foreign key references use `huntId: number`

**Step 4.3: Update authorization helpers**

File: `apps/backend/api/src/modules/hunts/hunt.service.ts`

```typescript
async verifyOwnership(huntId: number, userId: string): Promise<IHunt> {
  const hunt = await HuntModel.findOne({ huntId }).exec();

  if (!hunt) {
    throw new NotFoundError(`Hunt ${huntId} not found`);
  }

  if (hunt.creatorId !== userId) {
    throw new ForbiddenError('You do not own this hunt');
  }

  return hunt;
}
```

**Step 4.4: Test all CRUD operations**

Test suite checklist:
- [ ] Create hunt → Returns `huntId: 1001`
- [ ] Get hunt by ID → `GET /api/hunts/1001` works
- [ ] Update hunt → `PUT /api/hunts/1001` works
- [ ] Delete hunt → `DELETE /api/hunts/1001` works
- [ ] Create step → Returns `stepId: 10001`, `huntId: 1001`
- [ ] Update step → `PUT /api/hunts/1001/steps/10001` works
- [ ] Delete step → `DELETE /api/hunts/1001/steps/10001` works
- [ ] Reorder steps → `stepOrder` array uses numeric IDs

### Phase 5: Update OpenAPI & Types (15 minutes)

**Step 5.1: Update OpenAPI schema**

File: `packages/shared/openapi/hunthub_models.yaml`

Change field names and types (see [Implementation Pattern > 5. Update OpenAPI Schema](#5-update-openapi-schema)):
- `id: string` → `huntId: integer`
- `stepOrder: string[]` → `stepOrder: integer[]`

**Step 5.2: Regenerate TypeScript types**
```bash
npm run generate
```

**Step 5.3: Fix type errors**

TypeScript will now show errors where code expects old types:
```typescript
// Before
interface Hunt {
  id: string;  // ❌ Old
}

// After
interface Hunt {
  huntId: number;  // ✅ New
}
```

Fix imports across codebase:
```bash
# Search for old field names
grep -r "\.id" apps/backend/api/src/
grep -r '"id"' apps/backend/api/src/

# Replace with huntId/stepId
```

**Step 5.4: Verify compilation**
```bash
npm run build

# Should compile without errors
```

### Phase 6: MongoDB RBAC Setup (15 minutes)

**Step 6.1: Create setup script**

File: `apps/backend/api/scripts/setup-mongodb-rbac.sh`

```bash
#!/bin/bash

MONGO_URI="${MONGO_URI}"
APP_PASSWORD="${MONGODB_APP_PASSWORD}"

mongosh "$MONGO_URI" --eval "
  use hunthub;

  // Create restricted role for app
  db.createRole({
    role: 'hunthubApp',
    privileges: [
      // Counters: read and update ONLY (NO delete)
      {
        resource: { db: 'hunthub', collection: 'counters' },
        actions: ['find', 'update']
      },

      // Other collections: full CRUD
      {
        resource: { db: 'hunthub', collection: 'hunts' },
        actions: ['find', 'insert', 'update', 'remove']
      },
      {
        resource: { db: 'hunthub', collection: 'steps' },
        actions: ['find', 'insert', 'update', 'remove']
      },
      {
        resource: { db: 'hunthub', collection: 'users' },
        actions: ['find', 'insert', 'update', 'remove']
      }
    ],
    roles: []
  });

  // Create app user with restricted permissions
  db.createUser({
    user: 'hunthubApp',
    pwd: '$APP_PASSWORD',
    roles: ['hunthubApp']
  });

  print('✅ MongoDB RBAC configured');
  print('✅ User hunthubApp created with restricted permissions');
  print('⚠️  Counters collection is protected from deletion');
"
```

**Step 6.2: Run RBAC setup**
```bash
chmod +x apps/backend/api/scripts/setup-mongodb-rbac.sh
./apps/backend/api/scripts/setup-mongodb-rbac.sh
```

**Step 6.3: Update connection string**

File: `.env` or `.env.local`

```bash
# Before (admin connection)
MONGO_URI=mongodb://admin:password@localhost:27017/hunthub

# After (app user connection)
MONGO_URI=mongodb://hunthubApp:${MONGODB_APP_PASSWORD}@localhost:27017/hunthub
```

**Step 6.4: Test RBAC protection**
```bash
mongosh "mongodb://hunthubApp:password@localhost:27017/hunthub" --eval "
  use hunthub;

  // This should WORK
  db.counters.findOne({ name: 'hunt' });

  // This should FAIL
  db.counters.deleteOne({ name: 'hunt' });
  // Error: not authorized on hunthub to execute command
"
```

### Phase 7: Testing & Validation (30 minutes)

**Step 7.1: Manual API testing**

Test all endpoints with numeric IDs:
```bash
# Create hunt
POST /api/hunts
→ Response: { huntId: 1002, ... }

# Get hunt
GET /api/hunts/1002
→ Response: { huntId: 1002, ... }

# Create step
POST /api/hunts/1002/steps
→ Response: { stepId: 10002, huntId: 1002, ... }

# Get hunt with steps
GET /api/hunts/1002
→ Response: { huntId: 1002, stepOrder: [10002], ... }

# Delete step
DELETE /api/hunts/1002/steps/10002
→ Response: 204 No Content
→ Hunt stepOrder should be empty

# Delete hunt
DELETE /api/hunts/1002
→ Response: 204 No Content
```

**Step 7.2: Update integration tests**

File: `apps/backend/api/tests/integration/hunts/huntCrud.test.ts`

Update assertions to use numeric IDs:
```typescript
it('should create a new hunt and return 201', async () => {
  const response = await request(app)
    .post('/api/hunts')
    .set('Authorization', `Bearer ${authToken}`)
    .send(huntData)
    .expect(201);

  expect(response.body).toMatchObject({
    huntId: expect.any(Number),  // ✅ Changed from 'id'
    name: huntData.name,
    status: 'draft',
    stepOrder: []
  });

  // Verify numeric ID in range
  expect(response.body.huntId).toBeGreaterThanOrEqual(1000);
});
```

**Step 7.3: Run test suite**
```bash
npm test

# All tests should pass
```

**Step 7.4: Verify counter behavior**

Create 10 hunts and verify IDs are sequential:
```bash
for i in {1..10}; do
  curl -X POST http://localhost:3000/api/hunts \
    -H "Authorization: Bearer <token>" \
    -d "{\"name\": \"Hunt $i\"}"
done

# Should get huntIds: 1000, 1001, 1002, ..., 1009
```

Check for gaps (acceptable):
```bash
# Try to create hunt but cancel
curl -X POST http://localhost:3000/api/hunts \
  -H "Authorization: Bearer <token>" \
  -d '{"invalid": "data"}'  # Validation error

# Next successful hunt might be 1011 (gap at 1010 is OK)
```

### Phase 8: Documentation & Cleanup (15 minutes)

**Step 8.1: Update API documentation**

Add note about numeric IDs to:
- `apps/backend/api/README.md`
- `.claude/backend/current-state.md`

**Step 8.2: Remove old migration plan**
```bash
rm .claude/backend/NUMERIC-ID-MIGRATION-PLAN.md
```

**Step 8.3: Update roadmap**

File: `.claude/ROADMAP.md`

Mark numeric ID migration as complete:
```markdown
- [x] 🔥 Numeric ID Migration (COMPLETE - 2025-10-31)
  - Hunt and Step models use numeric IDs
  - Counter pattern implemented
  - MongoDB RBAC configured
```

**Step 8.4: Git commit**
```bash
git add .
git commit -m "feat: implement numeric IDs for Hunt and Step

- Add Counter model with atomic increment
- Update Hunt model: add huntId field, pre-save hook
- Update Step model: add stepId field, pre-save hook
- Change foreign keys to use numeric IDs
- Update mappers to return numeric IDs
- Update services to query by numeric IDs
- Configure MongoDB RBAC to protect counters
- Update OpenAPI schema and regenerate types
- All tests passing

Breaking changes:
- API responses now use 'huntId' instead of 'id'
- API responses now use 'stepId' instead of 'id'
- stepOrder array contains numbers instead of ObjectIds

Refs: .claude/backend/NUMERIC-ID-IMPLEMENTATION.md"
```

### Phase 9: Deployment Checklist

**Before deploying to production:**

- [ ] Run `npm run init-counters` in production MongoDB
- [ ] Run `setup-mongodb-rbac.sh` in production
- [ ] Update production `MONGO_URI` to use `hunthubApp` user
- [ ] Verify app can create hunts and steps
- [ ] Verify app CANNOT delete counters
- [ ] Test all API endpoints with numeric IDs
- [ ] Update frontend to use `huntId` and `stepId` fields
- [ ] Monitor logs for "Counter not found" errors

**Rollback plan:**

If issues occur:
1. Revert to previous commit (before numeric IDs)
2. Restore MongoDB from backup (if data corrupted)
3. Frontend should gracefully handle both old and new ID formats during transition

---

## Testing Strategy

### Unit Tests

**Test Counter model:**
```typescript
describe('Counter Model', () => {
  it('should generate sequential IDs', async () => {
    const id1 = await getNextSequence('hunt');
    const id2 = await getNextSequence('hunt');
    const id3 = await getNextSequence('hunt');

    expect(id1).toBe(1000);
    expect(id2).toBe(1001);
    expect(id3).toBe(1002);
  });

  it('should throw if counter not initialized', async () => {
    await expect(getNextSequence('nonexistent'))
      .rejects
      .toThrow("Counter 'nonexistent' not found");
  });
});
```

**Test pre-save hooks:**
```typescript
describe('Hunt Model', () => {
  it('should auto-generate huntId on create', async () => {
    const hunt = await HuntModel.create({
      creatorId: 'user-123',
      name: 'Test Hunt'
    });

    expect(hunt.huntId).toBeDefined();
    expect(hunt.huntId).toBeGreaterThanOrEqual(1000);
  });

  it('should not regenerate huntId on update', async () => {
    const hunt = await HuntModel.create({
      creatorId: 'user-123',
      name: 'Test Hunt'
    });

    const originalId = hunt.huntId;

    hunt.name = 'Updated Hunt';
    await hunt.save();

    expect(hunt.huntId).toBe(originalId);
  });
});
```

### Integration Tests

**Test concurrent ID generation:**
```typescript
describe('Counter Concurrency', () => {
  it('should handle concurrent requests without duplicate IDs', async () => {
    // Create 100 hunts concurrently
    const promises = Array.from({ length: 100 }, (_, i) =>
      HuntModel.create({
        creatorId: 'user-123',
        name: `Concurrent Hunt ${i}`
      })
    );

    const hunts = await Promise.all(promises);
    const huntIds = hunts.map(h => h.huntId);

    // All IDs should be unique
    const uniqueIds = new Set(huntIds);
    expect(uniqueIds.size).toBe(100);

    // All IDs should be in expected range
    huntIds.forEach(id => {
      expect(id).toBeGreaterThanOrEqual(1000);
      expect(id).toBeLessThan(1100);
    });
  });
});
```

**Test foreign key references:**
```typescript
describe('Step-Hunt Relationship', () => {
  it('should use numeric foreign key', async () => {
    const hunt = await HuntModel.create({
      creatorId: 'user-123',
      name: 'Test Hunt'
    });

    const step = await StepModel.create({
      huntId: hunt.huntId,  // Numeric foreign key
      type: 'clue',
      challenge: { clue: { title: 'Test', description: 'Test' } }
    });

    expect(step.huntId).toBe(hunt.huntId);
    expect(typeof step.huntId).toBe('number');
  });

  it('should query steps by hunt numeric ID', async () => {
    const hunt = await HuntModel.create({
      creatorId: 'user-123',
      name: 'Test Hunt'
    });

    await StepModel.create({
      huntId: hunt.huntId,
      type: 'clue',
      challenge: { clue: { title: 'Step 1', description: 'Test' } }
    });

    await StepModel.create({
      huntId: hunt.huntId,
      type: 'quiz',
      challenge: { quiz: { title: 'Step 2', type: 'choice', target: { id: '1', text: 'A' } } }
    });

    const steps = await StepModel.find({ huntId: hunt.huntId }).exec();

    expect(steps).toHaveLength(2);
    expect(steps.every(s => s.huntId === hunt.huntId)).toBe(true);
  });
});
```

### Manual Testing Checklist

- [ ] Create hunt → Verify `huntId` starts at 1000
- [ ] Create 10 hunts → Verify IDs are sequential (1000-1009)
- [ ] Create step → Verify `stepId` starts at 10000
- [ ] Create step in multiple hunts → Verify `stepId` increments globally
- [ ] Delete hunt → Verify next hunt ID doesn't reuse deleted ID
- [ ] API returns numeric IDs (not ObjectIds)
- [ ] Hunt `stepOrder` contains numeric IDs
- [ ] Can query hunt by numeric ID: `GET /api/hunts/1332`
- [ ] Can query step by numeric ID: `GET /api/steps/10045`
- [ ] Authorization works with numeric IDs
- [ ] Cannot delete counter via app (RBAC protection)

---

## Production Standards Reference

### What Big Companies Actually Do

**GitHub:**
- Issue numbers: Sequential integers (#1, #2, #3...)
- Per-repository counters
- Safe with authorization (can't access private repo issues)
- Uses: `owner/repo#123` format

**Twitter/Instagram:**
- Snowflake IDs: 64-bit integers
- Generated directly (not translated from UUID)
- Encodes: timestamp + datacenter + worker + sequence
- Globally unique, sortable by time

**Stripe:**
- Prefixed random strings: `cus_1A2B3C4D`
- NOT sequential (security by obscurity)
- Uses: UUIDs with friendly prefixes

**Production pattern for MongoDB:**
- Use counter collection with atomic increment
- Store numeric ID in document alongside ObjectId
- Query by numeric ID (indexed)
- ObjectId used for internal references (populate)
- RBAC to protect counters from deletion

### Why This Pattern Is Standard

1. **Battle-tested:** Instagram uses this pattern at massive scale
2. **MongoDB best practice:** Recommended in official docs
3. **Simple:** No complex ID generation algorithms
4. **Reliable:** MongoDB atomic operations guarantee uniqueness
5. **Flexible:** Can switch to Snowflake IDs later without API changes

### Scaling Considerations

**HuntHub scale (thousands of hunts):**
- ✅ Simple counter is perfect
- ✅ No performance issues

**Massive scale (millions of hunts, sharded database):**
- Consider Snowflake IDs (distributed generation)
- Or: Separate counter per shard
- But: Likely won't reach this scale

**Counter bottleneck at what scale?**
- Single MongoDB instance: 10,000+ writes/second
- HuntHub expected: <10 writes/second
- **Headroom: 1000x before any concern**

---

## Summary

**What We Implemented:**
- ✅ Numeric sequential IDs for Hunt (1000+) and Step (10000+)
- ✅ Counter collection with atomic increment
- ✅ Pre-save hooks for automatic ID generation
- ✅ MongoDB RBAC to protect counters
- ✅ Pre-initialization script for deployment
- ✅ Updated all queries to use numeric IDs
- ✅ Updated mappers to return numeric IDs
- ✅ Updated OpenAPI schema

**Why This Matters:**
- ✅ Production-quality security (no ObjectId exposure)
- ✅ Better user experience (short, memorable IDs)
- ✅ Industry standard pattern (GitHub, Twitter, Stripe)
- ✅ Database-agnostic API (can migrate from MongoDB later)
- ✅ Portfolio demonstration of best practices

**Time Investment:**
- Setup: ~2 hours
- Testing: ~30 minutes
- Documentation: ~30 minutes
- **Total: ~3 hours**

**Result:**
- Professional, production-ready API
- Human-readable URLs: `/play/1332`
- Safe, atomic, reliable ID generation
- Zero risk of race conditions or duplicates
- Template-ready pattern for future projects

---

**Document version:** 1.0
**Last updated:** 2025-10-31
**Next review:** After implementation complete
